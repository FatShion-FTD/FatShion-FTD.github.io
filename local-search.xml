<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>旅鼠2</title>
    <link href="/2025/02/07/%E6%97%85%E9%BC%A02/"/>
    <url>/2025/02/07/%E6%97%85%E9%BC%A02/</url>
    
    <content type="html"><![CDATA[<p>旅鼠跳了下去.</p><p>但他也曾试过在鼠潮中逆流而上. 结果自然是失败, 被裹挟着, 卷带着, 胁迫着, 他就跳了下去.</p><p>山崖很高, 也很陡峭, 山名叫做学术山, 听说只有最聪明的旅鼠才有资格从这里跳. 所以自由落体时间更长, 他有更多的时间去回忆作为旅鼠的一生, 他到底有什么意义.</p><p>回忆应该从哪里开始? </p><p>是 2014 年的那个夏天, 看到分班结果的那天? 不是.</p><p>是 2017 年的高考志愿, 阴差阳错的修改了志愿顺序那天? 不是.</p><p>是 2019 年的那场交换, 终于长了见识的那天? 不是.</p><p>是 2021 年的放弃安稳, 终日刷题励志誓要去美国的那天? 不是.</p><p>还是 2024 年他终于跳了下去, 想要回忆过去却惶惶不可终日的那天?</p><p>都不是.</p><p>旅鼠, lemmings, 或许这个生物的存在, 从一开始就是一场意外, 人类的 DNA 尚且是一团乱麻, 偌大的自然界, BUG总是会存在的. 这个千万年来的漏网之鱼, 就是 旅鼠.</p><p>旅鼠就不应该存在.</p><p>既然活着的意义就是奔向一场华丽而盛大的死亡. 那何不干脆向死而生?</p><p>我, 向死, 学术山的海拔很高, 还有着心跳; 而生, 这场下落我将活过, 只活这一次.</p><p>YOLO: You Only Look(LIVE) Once</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>旅鼠</title>
    <link href="/2024/03/03/%E6%97%85%E9%BC%A0/"/>
    <url>/2024/03/03/%E6%97%85%E9%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="旅鼠"><a href="#旅鼠" class="headerlink" title="旅鼠"></a>旅鼠</h1><p>旅鼠 Lemming, a kind of small rodent, 一種在迪士尼筆下有著神奇魔力的生物. 動畫師筆下的他們除了怯懦和恐懼之外, 就是擁有一個人類怎麽都無法理解的夢想, 找到一個海岸, 縱身一躍, 從而達到自己鼠生的意義.</p><p>我以前不理解, 只是覺得這種行爲很蠢. 但是就像我名字中的拼音, 我可能冥冥之中就會和這種生物產生交集.</p><p>我的失敗始於2014年, 那一年是中考, 一個同班的女孩, 用好聼的話形容我對她的態度是, 她是我的白月光, 稍微難聼點, 我就是一個只敢在阴暗的角落偷偷看着她的廢物. 我們考得了一模一樣的分數, 然而我們的人生卻開始了完全不同的路綫.</p><p>3個月后, 我再次回到了這間學校, 沒錯這間學校的初中生以考入本校高中部爲己任, 她的名字卻並不在普高部的分班表裏, 而是在一種叫做國際部的地方, 我們的樓上, 我在4楼, 她在7楼. </p><p>那時我並不知道國際部有什麽特權, 有什麽優勢, 不過在家長的言辭下, 我認爲那裏是學習不好的學生去的地方, 而我也不理解她, 爲什麽要去那種地方讀書. 但我已經隱隱覺得, 當時的我和樓上, 已經有一道細細的裂痕正在產生了.</p><p>高中一年級, 我遇到了一位要好的朋友, 通過他的話, 我得以一窺一個我之前前所未見的世界, 國際部的畢業生能夠獲得海外的畢業證從而直入海外的本科, 但是的我天真的以爲這不過如此, 後來被證明, 我錯了, 我大錯特錯了.</p><p>因爲不再在一起上課, 我就沒有機會再看到她, 連作爲同學的資格也被抹去了. 只是想再當一次同學, 再看幾眼. 如此卑微的想法, 就宛如一隻 rodent 想要看一眼草原上一片最肥沃的水草. 所以我開始想要轉入國際部, 然而這一切不過是家長眼裏敗家的表現, 交涉失敗開始對峙, 甚至沒有什麽堅持, 我便乖乖繳械, 結局自然也在意料之中了.</p><p>高中三年, 我很少再去想她的事情, 不過和國際部的往來卻不知不覺的增加了, steam裏現在還有那時在網吧加的國際部好友, 而自己班同學的qq都沒有加過一半.</p><p>意料之外的事情在高中結束的時候發生了, 我沒有考好, 能上的好學校並不多, 更罔論其中的好專業了, 於是在人生的選擇上, 潛移默化的轉變就在此時顯現, 我去了閒在大陸的外國學校分校, 至於爲什麽去, 去的理由是什麽, 我到現在也不清楚, 就像一張卷子, 兩面都印著考題卻在每一頁右下角都有 ‘答案參加翻面’ 一樣.</p><p>我到了這件大學後, 水的課程, 無趣的生活讓時間飛逝. 唯一清晰的記憶就是在大一的寒假, 和舊友吃飯的談話閒, 我不經意的聼到了她所在的大學, 在 Vancouver. 同时还有一个信息, 她的精神状态不太好, 高中的几年, 她朋友不多, 周围的人也她当作异类. 我确信她的精神状态不是因为我, 但是我知道, 我的精神状态是因为她. 我一直想説服自己那是不經意閒聼到了, 并不是我故意打聽的. 目前看來效果不錯. </p><p>大二的暑假, 家裏讓參加暑校, 去外面漲漲見聞, 於是我開始了暑校的申請, 但寫了申請信給本校校方發出後, 學校莫名其妙地回復給我了一個我從未申請的項目, 明明申請的都是日本, 歐洲和美國的, 但是回復的申請信確實是來自加拿大, 一所我根本没有申请的学校. 我當時并沒有意識到, 這間學校竟然就是她所在的學校.</p><p>就那麽稀里糊塗的踏上了前往溫哥華的飛機, 旅途也是順利, 但卻的確地被震撼了. 坐落在西溫和北溫的別墅, 留學生開的超跑, 可水可硬的課程和排名五十以内的高校. 那個月我在想, 這樣的生活是我這種 rodent 應該體驗的嗎, 這種見識漲了真的有什麽用嗎. 盡管如此, 如此見聞依然獲益繁多, 至少它顛覆了我之前對於國際部的認知, 原來國際部的人畢業了來的都是這種地方, 上的都是這種大學. 他們比我們強.</p><p>这是我写在去美国之前的故事. 现在这个故事可以继续了. 说是故事, 却是无聊到了极致.</p><p>我到了美国. 在蛊惑下, 他们说着这里有大包, 有好的工作, 无限的机会, 我也就那么相信了. 是的, 直到我来之前, 事实的确如此. 但是在我来的第二天, 市场开始了紧缩, 工作的机会烟消云散, 整个2021到2022如梦似幻. 我来这里的唯一理由没有了. Lemming 一样跟着大部队, 我动了.</p><p>之前, 我在荷兰, 毕业后留下问题应该不大. 但是我选择了离开, 我想是 rodent 的天性在作祟. 离开了带着柔软草甸的悬崖, 纵身一跃, 我跳了下来. 下面是万丈深渊.</p><p>现在我什么都没有, <strong>胆小, 懦弱</strong>, 同时<strong>狂妄, 自大, 自以为是</strong>.</p><p>我<strong>罪有应得</strong>, 旅鼠的生涯的确就该这样结束.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Prompt Eng</title>
    <link href="/2023/04/01/Prompt-Eng/"/>
    <url>/2023/04/01/Prompt-Eng/</url>
    
    <content type="html"><![CDATA[<h1 id="三个原则"><a href="#三个原则" class="headerlink" title="三个原则"></a>三个原则</h1><ol><li>清晰 Clear: 理解手头的主题或任务，并能够生成适当的响应。避免使用过于复杂或模糊的语言，力求在提示中尽可能具体。</li><li>聚焦 Focus: 定义清晰的提示应具有明确的目的和焦点，有助于引导对话并保持正确的轨道。避免使用过于广泛或开放式的提示，这可能会导致不连贯或缺乏焦点的对话</li><li>相关性 Relavant: 避免引入无关的主题或离题的内容，这可能会分散对话的主要焦点</li></ol><h1 id="四个注意"><a href="#四个注意" class="headerlink" title="四个注意"></a>四个注意</h1><ol><li><strong>明确会话的目的和焦点</strong>。在编写提示之前，有一个清晰的想法很重要，即您想通过会话实现什么目标。您的目标是提供信息、回答问题还是进行随意交谈？明确会话的目的和焦点将有助于您编写一个特定且相关的提示，从而实现更具吸引力和信息性的会话, 例如:    <blockquote><p><strong>Prompt:</strong> I want to buy a new car. The car should be oil efficient and have a good safety rating.</p></blockquote></li></ol><hr><p>此时 I want to buy a new car 就是目的和焦点, 在提示输入的开头和结尾进行强调, 以便 ChatGPT 能够更好的理解提示的意图.</p><ol start="2"><li><strong>使用具体和相关的语言</strong>。为了确保 ChatGPT 理解您的提示并能够生成适当的响应，使用具体和相关的语言非常重要。避免使用术语或模棱两可的语言，这可能导致混淆或误解。相反，力求尽可能清晰简洁，使用与所讨论主题相关的语言。</li></ol><p>依然使用上述例子, 此时的具体相关语言就是: buy, car, oil efficient, safety rating. 相关即是扣题.</p><ol start="3"><li><strong>保持会话在正确的轨道上</strong>。当您参与 ChatGPT 对话时，保持关注所讨论的主题并避免引入与主题不相关的话题非常重要。通过保持会话在正确的轨道上，您可以确保它涵盖用户感兴趣的主题并提供有用和相关的信息。</li></ol><p>在上述例子中, 保持会话在正确的轨道上就是: 保持会话在购买新车的主题上, 而不是其他的主题. 比如: Who is the president of the United States? 这个问题就不是扣题.</p><ol start="4"><li><strong>避免开放性或过于广泛的提示</strong>。虽然为了获得更全面的响应而问开放性或过于广泛的问题很诱人，但这些类型的提示通常会导致不连贯或无焦点的对话。相反，力求在提示中尽可能具体，为会话定义明确的目的和焦点。</li></ol><p>同样看这个例子, 如果我只说: I want to buy a new car. 就会过分开放, 广泛. 导致 ChatGPT 的回复也会泛泛而谈.</p><h1 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h1><p>定义任何术语或技术术语。如果您需要在提示中使用术语或技术术语，请确保为这些术语提供清晰的定义或解释。这将有助于确保 ChatGPT 和用户在同一层面上，并避免误解. 例如:</p><blockquote><p><strong>Prompt:</strong> I want to write a hello world programm in programming language. </p></blockquote><hr><h2 id="此时的-programming-language-就是专业术语-需要定义-如果没有定义-LLM会自动选择一种语言-而这将会导致输出的模糊-因此-我们需要在提示中定义-programming-language-或者直接使用更加专业的术语直接称呼-例如-gt-Prompt-I-want-to-write-a-hello-world-programm-in-programming-language-C"><a href="#此时的-programming-language-就是专业术语-需要定义-如果没有定义-LLM会自动选择一种语言-而这将会导致输出的模糊-因此-我们需要在提示中定义-programming-language-或者直接使用更加专业的术语直接称呼-例如-gt-Prompt-I-want-to-write-a-hello-world-programm-in-programming-language-C" class="headerlink" title="此时的 programming language 就是专业术语, 需要定义. 如果没有定义, LLM会自动选择一种语言, 而这将会导致输出的模糊. 因此, 我们需要在提示中定义 programming language 或者直接使用更加专业的术语直接称呼. 例如:&gt; Prompt: I want to write a hello world programm in programming language C."></a>此时的 programming language 就是专业术语, 需要定义. 如果没有定义, LLM会自动选择一种语言, 而这将会导致输出的模糊. 因此, 我们需要在提示中定义 programming language 或者直接使用更加专业的术语直接称呼. 例如:<br>&gt; <strong>Prompt:</strong> I want to write a hello world programm in programming language C.</h2><h2 id="Or-gt-Prompt-I-want-to-write-a-hello-world-programm-in-C"><a href="#Or-gt-Prompt-I-want-to-write-a-hello-world-programm-in-C" class="headerlink" title="Or&gt; Prompt: I want to write a hello world programm in C."></a>Or<br>&gt; <strong>Prompt:</strong> I want to write a hello world programm in C.</h2><h1 id="提示修正"><a href="#提示修正" class="headerlink" title="提示修正"></a>提示修正</h1><p>同样的问题, 有时候我们会发现 ChatGPT 的回复不是我们想要的, 这时候我们可以对原提示进行修正, 以便 ChatGPT 能够更好的理解我们的意图.</p><h1 id="引导对话"><a href="#引导对话" class="headerlink" title="引导对话"></a>引导对话</h1><ol><li><strong>从一个清晰明了的提示开始</strong>。正如我们之前所讨论的那样，制定清晰明了的提示以定义对话的目的和重点是很重要的。通过以一个专注和具体的提示开始，您可以帮助确保对话保持在正确的轨道上，并覆盖用户感兴趣的主题。<br>例如: 你将以汽车购买指导员的身份为我提供帮助.</li><li><strong>鼓励 ChatGPT 扩展其回应</strong>。虽然 ChatGPT 能够提供有用和相关的信息，但有时鼓励它扩展其回应以提供更深入的信息或深入探讨相关主题会很有帮助。您可以通过提出跟进问题或提供额外的上下文或示例来引导对话。<br>例如: 你可以做到更多更相信的汽车细节, 加油.</li><li><strong>注意对话中使用的语气和语言</strong>。为了保持有意义和富有吸引力的对话，注意对话中使用的语气和语言是很重要的。避免使用过于随意或轻视的语言，因为这可能会导致沟通中断。相反，应采用尊重和专业的语气，并使用清晰易懂的语言。例如: 加入 “请”</li><li><strong>监控对话的方向并根据需要进行调整</strong>。随着对话的进行，监控它所采取的方向并根据需要进行调整是很重要的，以保持其正确的轨道。如果对话开始偏离主题，您可以使用提示或跟进问题将其引导回更相关的方向。</li></ol><h1 id="角色扮演"><a href="#角色扮演" class="headerlink" title="角色扮演"></a>角色扮演</h1><p>在 晰明了的提示开始 之中, 我们提出让 ChatGPT 扮演汽车购买指导员的角色. 这样做的好处是, 我们可以更加专注于汽车购买的问题, 而不是其他的问题. 任何问题都可以让chatGPT进行角色扮演来实现专一问题的回答</p><h1 id="提示链"><a href="#提示链" class="headerlink" title="提示链"></a>提示链</h1><h2 id="作为-对话模型-从上下文中进行学习是非常重要的-所以我们就需要循序渐进的指导-ChatGPT-进行回答-这种渐进过程就是提示链-零样本提示在我们第一次向-ChatGPT-提出问题时-ChatGPT-本身并没有任何的定制化上下文信息-所以此时的第一次提示是完全基于模型本身知识的-这就是零样本提示-例如-gt-Prompt-将文本分类为中性、负面或正面。文本：我认为这次假期还可以。情感："><a href="#作为-对话模型-从上下文中进行学习是非常重要的-所以我们就需要循序渐进的指导-ChatGPT-进行回答-这种渐进过程就是提示链-零样本提示在我们第一次向-ChatGPT-提出问题时-ChatGPT-本身并没有任何的定制化上下文信息-所以此时的第一次提示是完全基于模型本身知识的-这就是零样本提示-例如-gt-Prompt-将文本分类为中性、负面或正面。文本：我认为这次假期还可以。情感：" class="headerlink" title="作为 对话模型, 从上下文中进行学习是非常重要的. 所以我们就需要循序渐进的指导 ChatGPT 进行回答. 这种渐进过程就是提示链.## 零样本提示在我们第一次向 ChatGPT 提出问题时, ChatGPT 本身并没有任何的定制化上下文信息, 所以此时的第一次提示是完全基于模型本身知识的, 这就是零样本提示. 例如:&gt; Prompt:: 将文本分类为中性、负面或正面。文本：我认为这次假期还可以。情感："></a>作为 对话模型, 从上下文中进行学习是非常重要的. 所以我们就需要循序渐进的指导 ChatGPT 进行回答. 这种渐进过程就是提示链.<br>## 零样本提示<br>在我们第一次向 ChatGPT 提出问题时, ChatGPT 本身并没有任何的定制化上下文信息, 所以此时的第一次提示是完全基于模型本身知识的, 这就是零样本提示. 例如:<br>&gt; <strong>Prompt:</strong>: 将文本分类为中性、负面或正面。<br>文本：我认为这次假期还可以。<br>情感：</h2><blockquote><p><strong>output</strong>: 中性</p></blockquote><hr><h2 id="多样本提示"><a href="#多样本提示" class="headerlink" title="多样本提示"></a>多样本提示</h2><h2 id="使用零样本设置时，它们在更复杂的任务上仍然表现不佳。少样本提示可以作为一种技术，以启用上下文学习，我们在提示中提供演示以引导模型实现更好的性能。简而言之-提供一些例子-最好有有迹可循的规律-进行提示-例如-gt-Prompt-这太棒了！-x2F-x2F-Negative这太糟糕了！-x2F-x2F-Positive哇，那部电影太棒了！-x2F-x2F-Positive多么可怕的节目！-x2F-x2F"><a href="#使用零样本设置时，它们在更复杂的任务上仍然表现不佳。少样本提示可以作为一种技术，以启用上下文学习，我们在提示中提供演示以引导模型实现更好的性能。简而言之-提供一些例子-最好有有迹可循的规律-进行提示-例如-gt-Prompt-这太棒了！-x2F-x2F-Negative这太糟糕了！-x2F-x2F-Positive哇，那部电影太棒了！-x2F-x2F-Positive多么可怕的节目！-x2F-x2F" class="headerlink" title="使用零样本设置时，它们在更复杂的任务上仍然表现不佳。少样本提示可以作为一种技术，以启用上下文学习，我们在提示中提供演示以引导模型实现更好的性能。简而言之, 提供一些例子, 最好有有迹可循的规律, 进行提示. 例如:&gt; Prompt:: 这太棒了！&#x2F;&#x2F; Negative这太糟糕了！&#x2F;&#x2F; Positive哇，那部电影太棒了！&#x2F;&#x2F; Positive多么可怕的节目！&#x2F;&#x2F;"></a>使用零样本设置时，它们在更复杂的任务上仍然表现不佳。少样本提示可以作为一种技术，以启用上下文学习，我们在提示中提供演示以引导模型实现更好的性能。简而言之, 提供一些例子, 最好有有迹可循的规律, 进行提示. 例如:<br>&gt; <strong>Prompt:</strong>: 这太棒了！&#x2F;&#x2F; Negative<br>这太糟糕了！&#x2F;&#x2F; Positive<br>哇，那部电影太棒了！&#x2F;&#x2F; Positive<br>多么可怕的节目！&#x2F;&#x2F;</h2><blockquote><p><strong>output</strong>: Negative</p></blockquote><hr><p>在应用当中, 多样本提示事实上就是对话链, 是作为先验知识的存在.</p><h2 id="链式思考"><a href="#链式思考" class="headerlink" title="链式思考"></a>链式思考</h2><p>在提示链中, 我们可以使用链式思考的方式来进行提示.  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spark Intereview</title>
    <link href="/2023/03/16/Spark-Intereview/"/>
    <url>/2023/03/16/Spark-Intereview/</url>
    
    <content type="html"><![CDATA[<h1 id="大数据工具Spark的常见面试题"><a href="#大数据工具Spark的常见面试题" class="headerlink" title="大数据工具Spark的常见面试题"></a>大数据工具Spark的常见面试题</h1><p>Spark是一个基于内存计算的大数据处理框架，它可以实现批处理、流处理、机器学习、图计算等多种应用场景。Spark的优势在于其高效的分布式计算能力，以及丰富的API和组件。Spark也是目前大数据领域最热门的技术之一，因此掌握Spark相关的知识和技能对于求职者来说非常重要。</p><p>本文将介绍一些Spark的常见面试题，帮助大家复习和巩固Spark的核心概念和原理，以及掌握一些实际问题的解决方法。本文主要分为以下几个部分：</p><ul><li>Spark基础知识</li><li>Spark核心组件</li><li>Spark性能优化</li><li>Spark实战案例</li></ul><h2 id="Spark基础知识"><a href="#Spark基础知识" class="headerlink" title="Spark基础知识"></a>Spark基础知识</h2><h3 id="1-什么是Spark？"><a href="#1-什么是Spark？" class="headerlink" title="1. 什么是Spark？"></a>1. 什么是Spark？</h3><p>Spark是一个开源的大数据处理框架，它提供了一个统一的编程模型，让开发者可以使用Scala、Java、Python或R等语言编写并行化的应用程序，并运行在多种集群环境中。Spark最初由加州大学伯克利分校AMPLab开发，并于2013年成为Apache顶级项目。</p><h3 id="2-Spark有哪些特点？"><a href="#2-Spark有哪些特点？" class="headerlink" title="2. Spark有哪些特点？"></a>2. Spark有哪些特点？</h3><ul><li>基于内存计算：Spark可以将数据缓存在内存中进行多次迭代计算，避免了频繁地读写磁盘，从而提高了计算速度。</li><li>延迟计算：Spark采用了延迟计算（lazy evaluation）的策略，即只有当需要输出结果时才会触发真正的计算过程，这样可以避免不必要的中间结果生成和传输。</li><li>弹性分布式数据集（RDD）：RDD是Spark最核心的抽象概念，它表示一个可并行操作、可容错、可缓存、只读的分布式数据集合。RDD支持两种类型的操作：转换（transformation）和行动（action）。转换操作会生成新的RDD，而行动操作会触发真正的计算并返回结果。</li><li>DAG调度引擎：DAG（Directed Acyclic Graph）是有向无环图的缩写，它表示一个任务执行过程中各个阶段之间依赖关系。Spark会将用户编写的程序转换为DAG，并根据DAG进行优化和调度。</li><li>统一编程模型：Spark提供了统一且丰富多样化API和组件库来支持不同类型和场景下大数据处理需求。例如：<ul><li>Spark SQL：支持结构化或半结构化数据查询与分析</li><li>Spark Streaming：支持流式数据处理与实时分析</li><li>MLlib：支持机器学习与推荐系统</li><li>GraphX：支持图形数据处理与分析</li></ul></li></ul><h3 id="3-Spark有哪些部署模式？"><a href="#3-Spark有哪些部署模式？" class="headerlink" title="3. Spark有哪些部署模式？"></a>3. Spark有哪些部署模式？</h3><ul><li>Local模式：在单机上运行，在本地测试或调试时使用。</li><li>Standalone模式：使用自带集群管理器，在单个或多个节点上运行。</li><li>YARN模式：使用Hadoop YARN作为集群管理器，在Hadoop集群上运行。</li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spring-1</title>
    <link href="/2022/12/17/spring-1/"/>
    <url>/2022/12/17/spring-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><p>不想自己写SQL? 不想和JDBC打交道? SQL语句自定义? 想直接返回对象集而不是ResultSet? </p><p>那就用Mybatis吧, 全自动映射, 半自动框架, 自定义各种你想要的.</p><p>Mybatis 数据库访问框架</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol><li>把混在Java代码里的JDBC去掉了</li><li>手动写SQL比Hibernate自动生成稳定</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Eclipse + SQLite + Maven + Mybatis</p><p>Maven工程内核心如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xerial<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sqlite-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>[算法分析] 动态规划 DP 之 1</title>
    <link href="/2022/12/07/dp2/"/>
    <url>/2022/12/07/dp2/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划 Dynamic Programming"></a>动态规划 Dynamic Programming</h1><p>第二部分, 就从 打家劫舍 开始吧.</p><h2 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h2><h3 id="打家劫舍系列"><a href="#打家劫舍系列" class="headerlink" title="打家劫舍系列"></a>打家劫舍系列</h3><p>隔一个抢一个,不能连着抢</p><p>子问题: 在当前时间 (<strong>第 i 家</strong>), 是 <strong>抢 i-1 家</strong> 还是 <strong>抢 i 和 i-2家</strong> 赚</p><p>转移方程: <strong>dp[i] &#x3D; max(dp[i-1], dp[i-2] + val);</strong></p><p>House Robber: <a href="https://leetcode.com/problems/house-robber/">https://leetcode.com/problems/house-robber/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> Math.max(nums[<span class="hljs-number">1</span>], nums[<span class="hljs-number">0</span>]);<br>    <br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">1</span>] = Math.max(nums[<span class="hljs-number">1</span>], nums[<span class="hljs-number">0</span>]);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; nums.length; i++)&#123;<br>        dp[i] = Math.max(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>] + nums[i]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[nums.length-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
      <tag>找工</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dijkstra 迪杰斯特拉算法 浅析</title>
    <link href="/2022/12/06/dijkstra-analysis/"/>
    <url>/2022/12/06/dijkstra-analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="Dijkstra-迪杰斯特拉算法"><a href="#Dijkstra-迪杰斯特拉算法" class="headerlink" title="Dijkstra 迪杰斯特拉算法"></a>Dijkstra 迪杰斯特拉算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个算法我第一次是在大一接触的, 当时的C语言课程, 最后的 final project 要求实现一个火车票购买系统, 给了好多单向的火车票, 要求目标两站之间最小花费, 我记得当时我用的极其过分的O($N^N$)遍历实现, 所以老师呢, 也给了我极其过分的 $及格^{及格}$ 分. 不出所料的, 那课 GPA 挺炸.</p><p>好啦, 那这个问题和 Dijkstra有什么关系呢? 实际上</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>最小路径优先的贪心思想 + </p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dijkstra</span> &#123;<br>    <span class="hljs-comment">// 图中节点的数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-comment">// 邻接矩阵，存储图中的边的权值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] adj;<br>    <span class="hljs-comment">// dist[i] 表示源点到节点 i 的最短路径距离</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] dist;<br>    <span class="hljs-comment">// pre[i] 表示源点到节点 i 的最短路径中，节点 i 的前驱节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] pre;<br>    <span class="hljs-comment">// 存储图中未被访问过的节点</span><br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; pq;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>        adj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];       <br>        <span class="hljs-comment">// 初始化所有边为无穷大</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] arr:adj)<br>            Arrays.fill(arr, Integer.MAX_VALUE);<br>        dist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br>        <span class="hljs-comment">// 初始化距离数组，所有节点到源点的距离都设为无穷大</span><br>        Arrays.fill(dist, Integer.MAX_VALUE);<br>        <span class="hljs-comment">// 初始化前驱节点数组，所有节点的前驱节点都设为源点</span><br>        Arrays.fill(pre, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 使用优先队列存储未访问过的节点</span><br>        pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; dist[a] - dist[b]);<br>    &#125;<br><br>    <span class="hljs-comment">// 计算源点到目标节点的最短路径</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> source, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-comment">// 将源点加入集合 S 中</span><br>        pq.offer(source);<br>        <span class="hljs-comment">// 将源点到源点的距离初始化为 0</span><br>        dist[source] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>            <span class="hljs-comment">// 取出当前最短路径最小的节点 u</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> pq.poll();<br>            <span class="hljs-comment">// 如果已遍历到目标节点，就退出循环</span><br>            <span class="hljs-keyword">if</span> (u == target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 遍历节点 u 的所有邻接节点 v</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; v &lt; n; v++) &#123;<br>                <span class="hljs-keyword">if</span> (adj[u][v] == Integer.MAX_VALUE)     <br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-comment">// 如果节点 v 未被访问过，并且从源点到节点 v 的距离比从源点到节点 u 再到节点 v 的距离更短</span><br>                <span class="hljs-keyword">if</span> (dist[v] &gt; dist[u] + adj[u][v]) &#123;<br>                    <span class="hljs-comment">// 更新源点到节点 v 的距离</span><br>                    dist[v] = dist[u] + adj[u][v];<br>                    <span class="hljs-comment">// 设置节点 v 的前驱节点为 u</span><br>                    pre[v] = u;<br>                    <span class="hljs-comment">// 将节点 v 加入集合 S 中</span><br>                    pq.offer(v);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取源点到目标节点的最短路径</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPath</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">// 从目标节点开始，不断查找它的前驱节点，直到找到源点为止</span><br>        <span class="hljs-keyword">while</span> (target != <span class="hljs-number">0</span>) &#123;<br>            sb.append(target + <span class="hljs-string">&quot; &lt;- &quot;</span>);<br>            target = pre[target];<br>        &#125;<br>        sb.append(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取源点到目标节点的最短路径距离</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">return</span> dist[target];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Dijkstra</span> <span class="hljs-variable">dijkstra</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dijkstra</span>(<span class="hljs-number">6</span>);<br>        <span class="hljs-comment">// 添加边，图中的边都是单向边</span><br>        dijkstra.adj[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        dijkstra.adj[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">4</span>;<br>        dijkstra.adj[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>        dijkstra.adj[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">7</span>;<br>        dijkstra.adj[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>        dijkstra.adj[<span class="hljs-number">2</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">2</span>;<br>        dijkstra.adj[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">5</span>;<br>        dijkstra.adj[<span class="hljs-number">3</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">1</span>;<br>        dijkstra.adj[<span class="hljs-number">4</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 计算源点到目标节点的最短路径</span><br>        dijkstra.dijkstra(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-comment">// 输出源点到目标节点的最短路径</span><br>        System.out.println(dijkstra.getPath(<span class="hljs-number">5</span>));<br>        <span class="hljs-comment">// 输出源点到目标节点的最短路径距离</span><br>        System.out.println(dijkstra.getDistance(<span class="hljs-number">5</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-number">5</span> &lt;- <span class="hljs-number">4</span> &lt;- <span class="hljs-number">2</span> &lt;- <span class="hljs-number">1</span> &lt;- <span class="hljs-number">0</span><br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
      <tag>找工</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[算法分析] 动态规划 DP 之 1</title>
    <link href="/2022/12/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-DP-%E4%B9%8B-1/"/>
    <url>/2022/12/04/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-DP-%E4%B9%8B-1/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划 Dynamic Programming"></a>动态规划 Dynamic Programming</h1><p>算法题里面最操蛋的, 想得出来就是想得出来, 想不出来拿铜头皮带把你抽的陀螺转你也想不出来的<br><strong>动态规划</strong><br>这是第一篇, 所以更像是 DP 从何而来, 要干什么, (去到哪里, 什么人生三问).<br>拙见, 拙见. 我连工作都没有!! 我是个傻逼!!!</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>动态规划来自于 DFS, 深度优先搜索. 在 DFS 中, 我们经常遇到一个问题, 就是重复搜索了. 明明这些东西都见过了, 但未来要跑的路, 还要再跑一遍, 这就导致了时间复杂度, 哧儿一下上去了. 所以就有了 记忆化 memorization, 来记忆一种名叫 <strong>状态</strong> 的东西. 状态是啥, 这不重要, 因为这个因问题而异. 但是有一点很重要, 状态记录了哪些东西见过了 或者 哪些东西他没见过, 这很重要, 因为有了这些信息, 跟据香农的信息熵理论, 我们就不再做无用功了, 因为可能性为 1 的事件, 不产生信息. 回到问题, 利用状态, 我们就能快速判断是否重复, 并在O(1)内给出当前状态下再往后走的解.</p><p>那么上述过程, 是一种 top-down 的寻找, 是我们定义好状态后, 去规避去躲开重复的路. 这其实已经是 DP 了, 但是这太被动了, 也不够 elegant (会不能和阿尼亚当同学的).</p><h3 id="数学part-跳过跳过"><a href="#数学part-跳过跳过" class="headerlink" title="数学part, 跳过跳过!!"></a>数学part, 跳过跳过!!</h3><p>现在带一点数学, Markov Process 马尔可夫过程. </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">設為一概率空間，另設集合為一指標集合。如果對於所有，均有一隨機變量定義於概率空間，則集合為一隨機過程。—Wikipedia<br></code></pre></td></tr></table></figure><p>wiki我也看不懂, 只是贴一下. 我的拙见是: 首先这是个概率模型, 变量们互相变来变去是跟据一个概率来的, 这个过程就是 Markov Process. 下面的那个好理解.</p><p>A stochastic process is said to be Markov if<br>$prob(s_{t+1}|s^t)&#x3D;prob(s_{t+1}|s_{t})$<br>where $s^{t}$ is the history up to period t and $s_{t}$ is the realization of the state at period t.</p><p>那这个玩意儿重要在哪里: 就是在随机过程中，明天的状态只取决于今天的状态. 和之前的状态无关啦。也就是不管你今儿是怎样达到 的，只要你今天的状态是 现在这个数值, 你明天状态的可能性就决定好了.</p><p>你看这个马尔可夫过程中确定明天状态的部分, 是不是和 DFS + memo 去躲避重复计算很像? 当然熟悉状态机的朋友, 一下也能看出来, 马尔可夫过程就是个概率分布的状态机. </p><p>那跟据马尔可夫过程是不是也能做和 DFS + memo 相同的事了呢? 是的, 但是需要一个概率模型.</p><p>在 Markov Process 中, 这个概率模型 也被称之为 转移矩阵 (Transition Mtrix) 而最终结果也被叫做稳态 (stable state). 初始的概率分布, 在经过无数次矩阵乘法过后, 状态会逐渐收敛到稳态.</p><p>示例: 如果状态空间只包含了两个状态A和B。如果今天是A,那么明天还是A的概率为0.8。如果今日是B,那么明天还是B的概率为0.7。一开始状态在A, 求稳态方程如下:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Matlab"><span class="hljs-comment">%initial pi%</span><br><span class="hljs-built_in">pi</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>];       <span class="hljs-comment">% 表示初始概率分布, 随便换</span><br><br><span class="hljs-comment">%transistion matrix%</span><br>P=[<span class="hljs-number">0.8</span>,<span class="hljs-number">0.2</span>;<span class="hljs-number">0.3</span>,<span class="hljs-number">0.7</span>];<br><br><span class="hljs-comment">%critical value%</span><br>cv=<span class="hljs-number">1</span>;           <span class="hljs-comment">% 当前状态和上一状态的状态差</span><br><br><span class="hljs-keyword">while</span> cv&gt;<span class="hljs-number">0.0000000001</span>;      <span class="hljs-comment">% 状态稳定, 即状态差收敛到够小</span><br>    pi2=<span class="hljs-built_in">pi</span>*P;               <span class="hljs-comment">% 当前状态 = 上一状态 * 转移矩阵</span><br>    cv=<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">min</span>(pi2-<span class="hljs-built_in">pi</span>));    <span class="hljs-comment">% 状态差</span><br>    <span class="hljs-built_in">pi</span>=pi2;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>这个 pi 结果最后是 0.6 和 0.4. 不管换什么初始都会稳定在这里. </p><p>此时问题来了, 面对问题, 我们从哪儿来这个转移矩阵? 答案是 对问题抽象, 寻找子问题. 我们看下上述代码, 无数次的矩阵乘法 就对应了 子问题的重复进行, 而初始状态就是我们问题开始时候的状态, 这个是固定的. 稳定态自然也不是咱们追求的, 咱们要的只是 问题所需的某一状态作为结束. </p><p>再简化一下: 在有限状态转移下, 从固定初始状态到固定终结状态的有限状态转移问题. </p><h2 id="简而言之"><a href="#简而言之" class="headerlink" title="简而言之"></a>简而言之</h2><p>最优子问题, 找 状态转移方程 进行子问题扩大 直到 原问题</p><p>思路: 1. 发现递归 -&gt; 2. 从上到下的递归 -&gt; 3. 加入 记忆 的递归 -&gt; 4. 递归 转 迭代 + 记忆-&gt; 5. 优化记忆空间</p><p>一般来说, 还是 直接 找 状态转移方程 直接写实在</p><p>例题: 打家劫舍1</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-发现递归-是-抢-i-1-家-还是-抢-i-和-i-2家-赚"><a href="#1-发现递归-是-抢-i-1-家-还是-抢-i-和-i-2家-赚" class="headerlink" title="1. 发现递归: 是 抢 i-1 家 还是 抢 i 和 i-2家 赚"></a>1. 发现递归: 是 <strong>抢 i-1 家</strong> 还是 <strong>抢 i 和 i-2家</strong> 赚</h3><h3 id="2-从终末状态开始-从上到下递归"><a href="#2-从终末状态开始-从上到下递归" class="headerlink" title="2. 从终末状态开始, 从上到下递归:"></a>2. 从终末状态开始, 从上到下递归:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">return</span> rob(nums, nums.length-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> Math.max(rob(nums, i-<span class="hljs-number">1</span>), rob(nums, i-<span class="hljs-number">2</span>) + nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-加入-记忆-的递归"><a href="#3-加入-记忆-的递归" class="headerlink" title="3. 加入 记忆 的递归"></a>3. 加入 记忆 的递归</h3><p>发现这家抢过了, 以后抢多抢少也确定了(算过了), 直接 return</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] memo;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> rob(nums, nums.length-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i)</span>&#123;<br>    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span>)   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(memo[i] != <span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> memo[i];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Math.max(rob(nums, i-<span class="hljs-number">1</span>), rob(nums, i-<span class="hljs-number">2</span>) + nums[i]);<br>    memo[i] = res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-递归-转-迭代-记忆"><a href="#4-递归-转-迭代-记忆" class="headerlink" title="4. 递归 转 迭代 + 记忆"></a>4. 递归 转 迭代 + 记忆</h3><p>状态转移从初始开始, 到终末状态结束. Markov Process 开始应用, 我不管你之前的状态了, 我就看后面. 从第一家开始抢, 到每家都看看, 是抢现在这家 + 上上一家 钱多 还是 抢上一家 钱多.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>[] memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length + <span class="hljs-number">1</span>];<br>    memo[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    memo[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> nums[i];<br>        memo[i+<span class="hljs-number">1</span>] = Math.max(memo[i], memo[i-<span class="hljs-number">1</span>] + val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> memo[nums.length];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-优化记忆空间"><a href="#5-优化记忆空间" class="headerlink" title="5. 优化记忆空间"></a>5. 优化记忆空间</h3><p>熟悉编译里面状态机的朋友看到这个带入状态机就好了, 3状态: 上一家prev2, 上上一家prev1, 现在.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">prev1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">prev2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> prev1;<br>        prev1 = Math.max(prev2 + num, prev1);<br>        prev2 = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev1;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
      <tag>找工</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mono-stack-analyse</title>
    <link href="/2022/12/04/mono-stack-analyse/"/>
    <url>/2022/12/04/mono-stack-analyse/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈-Mono-stack"><a href="#单调栈-Mono-stack" class="headerlink" title="单调栈 Mono-stack"></a>单调栈 Mono-stack</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>你是否觉着 Heap 比较虽然有大小, 但是没有了 序 order 很麻烦?<br>你是否觉着 有序序列 Ordered sequence 不能比较, 苦想白给?<br>单调栈, 它lei了.</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>来看下单调栈这个东西, 一种不怎么常见的数据结构. </p><p>首先来看下 stack 这个寄出到不能再基础的数据结构, FILO的属性决定了它具有前缀稳定 + 后缀操作 的特性.</p><p>啥是前缀稳定呢? 就是首先进入stack的数据, 不会与后续的数据 “见面”. 见不着面, 就没得比较, 没得操作, 所以稳定.</p><p>啥是后缀操作呢? 和上面那个反过来, 最新的数据 和 次新的数据 是在一直见面的, 他们之间就能比较, 能操作. </p><p>好了, 这是stack的属性. 跟您单调栈有嘛关系? 关系就是, 我还是个stack, 里面的东西有了 单增 或者 单减 的属性啦!</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>test_article</title>
    <link href="/2022/12/04/test-article/"/>
    <url>/2022/12/04/test-article/</url>
    
    <content type="html"><![CDATA[<h1 id="香香-我的香香"><a href="#香香-我的香香" class="headerlink" title="香香, 我的香香"></a>香香, 我的香香</h1><h2 id="hexo-支持的img导入办法"><a href="#hexo-支持的img导入办法" class="headerlink" title="hexo 支持的img导入办法"></a>hexo 支持的img导入办法</h2><img src="/2022/12/03/test-article/asuka1.jpg" class="" title="香香, 我的香香">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/12/04/hello-world/"/>
    <url>/2022/12/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g -d<br></code></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
